<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Scores</title>
  <link rel="stylesheet" href="styles.css" />
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
</head>
<body>
  <header class="header">
    <div class="header-content">
      <h1 class="header-title">ClimateBench 2.0</h1>
      <p class="header-subtitle">Climate Model Benchmarking & Analysis Platform</p>
    </div>
  </header>

  <nav class="navigation">
    <div class="nav-container">
      <ul class="nav-list">
        <li class="nav-item">
          <a href="index.html" class="nav-link">Overview</a>
        </li>
        <li class="nav-item">
          <a href="scores.html" class="nav-link active">Scores</a>
        </li>
        <li class="nav-item">
          <a href="input.html" class="nav-link">Input Data</a>
        </li>
      </ul>
    </div>
  </nav>

  <main>
    <h2>Benchmark Scores</h2>

    <div>
      <label for="filter-variable">Variable:</label>
      <select id="filter-variable">
        <option value="tas" selected>Surface Air Temperature</option>
        <option value="pr">Precipitation</option>
        <option value="tos">Sea Surface Temperature</option>
        <option value="clt">Cloud Area Fraction</option>
        <option value="od550aer">Aerosol Optical Depth at 550 nm</option>
      </select>

      <label for="filter-region">Region:</label>
      <select id="filter-region">
        <option value="global" selected>Global</option>
        <option value="northern_hemisphere">Northern Hemisphere</option>
        <option value="southern_hemisphere">Southern Hemisphere</option>
        <option value="tropics">Tropics</option>
      </select>

      <label for="filter-metric">Metric:</label>
      <select id="filter-metric">
        <option value="zonal_mean_mae" selected>MAE</option>
        <option value="zonal_mean_rmse">RMSE</option>
        <option value="zonal_mean_crps">CRPS</option>
        <option value="zonal_mean_mae_bias_adjusted">MAE (bias adjusted)</option>
        <option value="zonal_mean_rmse_bias_adjusted">RMSE (bias adjusted)</option>
        <option value="zonal_mean_crps_bias_adjusted">CRPS (bias adjusted)</option>
        <option value="zonal_mean_mae_anomaly">MAE (anomaly)</option>
        <option value="zonal_mean_rmse_anomaly">RMSE (anomaly)</option>
        <option value="zonal_mean_crps_anomaly">CRPS (anomaly)</option>
      </select>

      <label for="sort-column">Sort By:</label>
      <select id="sort-column">
        <option value="">None</option>
      </select>
    </div>

    <div style="overflow-x:auto; margin-top: 1em;">
      <table id="score-table" class="table" border="1" cellspacing="0" cellpadding="6">
        <thead></thead>
        <tbody></tbody>
      </table>
    </div>
    <h2> </h2>
    <label>Time Resolution:</label>
    <label><input type="radio" name="ts-resolution" value="monthly" checked> Monthly</label>
    <label><input type="radio" name="ts-resolution" value="annual"> Annual</label>
    <div id="time-series-plot" style="width:100%; height:500px; margin-top: 2em;"></div>
  </main>

  <footer><p>&copy; 2025 CAL.</p></footer>

  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <script>
    let allRows = [];
    let headers = [];
    let tsMonthly = [], tsAnnual = [];

    const headerDisplayNames = {
      "model": "Model Name",
      "Historical (2005-2014)": "Historical (2005-2014)",
      "SSP2-4.5": "SSP2-4.5",
      "Change (hist 2005)": "Change",
      "Percent Change (hist 2005)": "Percent Change",
    };

    function renderTable(data) {
      const table = document.getElementById('score-table');
      const thead = table.querySelector('thead');
      const tbody = table.querySelector('tbody');
      thead.innerHTML = '';
      tbody.innerHTML = '';

      // Remove the "variable", "metric", and "region" columns
      const visibleHeaders = headers.filter(h => !['variable', 'metric', 'region'].includes(h));

      const headerRow = document.createElement('tr');
      visibleHeaders.forEach(h => {
        const th = document.createElement('th');
        th.textContent = headerDisplayNames[h] || h;
        headerRow.appendChild(th);
      });
      thead.appendChild(headerRow);

      data.forEach(row => {
        const tr = document.createElement('tr');
        visibleHeaders.forEach(h => {
          const td = document.createElement('td');
          const val = row[h];
          const num = Number(val);
          const isPrecipitation = row['variable'] === 'pr';
          if (!isNaN(num) && isFinite(num)) {
            const isPercentChangeCol = h === "Percent Change (hist 2005)";
            if (isPrecipitation && !isPercentChangeCol) {
              td.textContent = num.toExponential(2); // scientific notation
            } else {
              td.textContent = num.toFixed(3); // normal format
            }
          } else {
            td.textContent = val;
          }
          tr.appendChild(td);
        });
        tbody.appendChild(tr);
      });

      const sortDropdown = document.getElementById('sort-column');
      if (sortDropdown && sortDropdown.options.length <= 1) {
        visibleHeaders.forEach(h => {
          if (h === "model") return;

          const opt = document.createElement('option');
          opt.value = h;
          opt.textContent = headerDisplayNames[h] || h;
          sortDropdown.appendChild(opt);
        });
      }
    }

    function applyFilters() {
      const varVal = document.getElementById('filter-variable').value;
      const metVal = document.getElementById('filter-metric').value;
      const regVal = document.getElementById('filter-region').value;

      const filtered = allRows.filter(row =>
        (!varVal || row['variable'] === varVal) &&
        (!metVal || row['metric'] === metVal) &&
        (!regVal || row['region'] === regVal)
      );

      const sortKey = document.getElementById('sort-column').value;

      if (sortKey) {
        filtered.sort((a, b) => {
          const va = parseFloat(a[sortKey]);
          const vb = parseFloat(b[sortKey]);
          if (isNaN(va) || isNaN(vb)) return 0;
          return va - vb; // ascending
        });
      }

      renderTable(filtered);
    }

    fetch('data/benchmark_results.csv')
      .then(res => res.text())
      .then(csv => {
        const parsed = Papa.parse(csv, { header: true });
        headers = parsed.meta.fields.slice(1); // skip unnamed index
        allRows = parsed.data.filter(row => row.model); // basic cleanup

        applyFilters(); // auto-filter on load with default dropdown values

        document.getElementById('filter-variable').addEventListener('change', applyFilters);
        document.getElementById('filter-metric').addEventListener('change', applyFilters);
        document.getElementById('filter-region').addEventListener('change', applyFilters);
        document.getElementById('sort-column').addEventListener('change', applyFilters);
      })
      .catch(err => {
        console.error("CSV loading error:", err);
        document.getElementById('score-table').outerHTML = "<p>Error loading benchmark results.</p>";
      });

    // After existing fetch for benchmark_results.csv...
    fetch('data/benchmark_results_time_series.csv')
      .then(res => res.text())
      .then(csv => {
        tsMonthly = Papa.parse(csv, { header: true, dynamicTyping: true }).data;
        setupTimeSeries();
      });

    fetch('data/benchmark_results_time_series_annual.csv')
      .then(res => res.text())
      .then(csv => {
        tsAnnual = Papa.parse(csv, { header: true, dynamicTyping: true }).data;
        setupTimeSeries();
      });

    function setupTimeSeries() {
      const plotDiv = document.getElementById('time-series-plot');

      function updatePlot() {
        const varVal = document.getElementById('filter-variable').value;
        const regVal = document.getElementById('filter-region').value;
        const metVal = document.getElementById('filter-metric').value;
        const resolution = document.querySelector('input[name="ts-resolution"]:checked').value;

        const metValChart = metVal === "zonal_mean_rmse"
          ? "RMSE"
          : metVal === "zonal_mean_mae"
            ? "MAE"
            : NaN;

        const tsData = resolution === "monthly" ? tsMonthly : tsAnnual;
        const timeKey = resolution === "monthly" ? "time" : "year";
        const filtered = tsData.filter(d =>
          d.variable === varVal &&
          d.metric === metValChart
        );

        const traces = {};
        filtered.forEach(d => {
          const m = d.model;
          const yVal = parseFloat(d[regVal]);
          if (!isFinite(yVal)) return;

          if (!traces[m]) traces[m] = { x: [], y: [], name: m };
          traces[m].x.push(d[timeKey]);
          traces[m].y.push(yVal);
        });

        const data = Object.values(traces);
        const layout = {
          title: `${metValChart} over ${resolution} time for ${varVal} (${regVal.replace('_', ' ')})`,
          // xaxis: { title: resolution === "monthly" ? "Month" : "Year" },
          yaxis: { title: metValChart },
          legend: { orientation: 'h', x: 0, y: -0.1 }
        };

        Plotly.newPlot(plotDiv, data, layout, { responsive: true });
      }

      // Add listeners
      ['filter-variable','filter-region','filter-metric'].forEach(id => {
        document.getElementById(id).addEventListener('change', updatePlot);
      });
      document.querySelectorAll('input[name="ts-resolution"]').forEach(input => {
        input.addEventListener('change', updatePlot);
      });

      updatePlot(); // initial render
    }
  </script>
</body>
</html>