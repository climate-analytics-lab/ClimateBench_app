<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Scores</title>
  <link rel="stylesheet" href="styles.css" />
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
</head>
<body>
  <header class="header">
    <div class="header-content">
      <h1 class="header-title">ClimateBench 2.0</h1>
      <p class="header-subtitle">Climate Model Benchmarking & Analysis Platform</p>
    </div>
  </header>

  <nav class="navigation">
    <div class="nav-container">
      <ul class="nav-list">
        <li class="nav-item">
          <a href="index.html" class="nav-link">Overview</a>
        </li>
        <li class="nav-item">
          <a href="scores.html" class="nav-link active">Scores</a>
        </li>
        <li class="nav-item">
          <a href="input.html" class="nav-link">Input Data</a>
        </li>
        <li class="nav-item">
          <a href="paleo.html" class="nav-link">Paleoclimate Data</a>
        </li>
      </ul>
    </div>
  </nav>

  <main class="main-content">
    <div class="probabilistic-scores">
      <h2 class="section-title">Data Selection</h2>
      
      <div class="widget-menu">
        <div class="widget-row">
          <div class="widget-group">
            <label for="filter-variable">Variable</label>
            <select id="filter-variable" class="widget-select">
              <option value="tas" selected>Surface Air Temperature</option>
              <option value="pr">Precipitation</option>
              <option value="tos">Sea Surface Temperature</option>
              <option value="clt">Cloud Area Fraction</option>
              <option value="od550aer">Aerosol Optical Depth at 550 nm</option>
            </select>
          </div>

          <div class="widget-group">
            <label for="filter-region">Region</label>
            <select id="filter-region" class="widget-select">
              <option value="global" selected>Global</option>
              <option value="northern_hemisphere">Northern Hemisphere</option>
              <option value="southern_hemisphere">Southern Hemisphere</option>
              <option value="tropics">Tropics</option>
            </select>
          </div>

          <div class="widget-group">
            <label for="filter-metric">Metric</label>
            <select id="filter-metric" class="widget-select">
              <option value="zonal_mean_mae" selected>MAE</option>
              <option value="zonal_mean_rmse">RMSE</option>
              <option value="zonal_mean_crps">CRPS</option>
              <option value="zonal_mean_mae_bias_adjusted">MAE (bias adjusted)</option>
              <option value="zonal_mean_rmse_bias_adjusted">RMSE (bias adjusted)</option>
              <option value="zonal_mean_crps_bias_adjusted">CRPS (bias adjusted)</option>
              <option value="zonal_mean_mae_anomaly">MAE (anomaly)</option>
              <option value="zonal_mean_rmse_anomaly">RMSE (anomaly)</option>
              <option value="zonal_mean_crps_anomaly">CRPS (anomaly)</option>
            </select>
          </div>

          <div class="widget-group">
            <label for="sort-column">Sort By</label>
            <select id="sort-column" class="widget-select">
              <option value="">None</option>
            </select>
          </div>

          <div class="widget-group">
            <label>Time Resolution</label>
            <div style="display: flex; gap: 20px; align-items: center; padding: 12px 0;">
              <label style="margin: 0; display: flex; align-items: center; gap: 8px;">
                <input type="radio" name="ts-resolution" value="annual" checked style="margin: 0;">
                Annual
              </label>
              <label style="margin: 0; display: flex; align-items: center; gap: 8px;">
                <input type="radio" name="ts-resolution" value="monthly" style="margin: 0;">
                Monthly
              </label>
            </div>
          </div>
        </div>
      </div>

      <h2 class="section-title">Benchmark Scores</h2>
      <p>The following scores are calculated using the zonal mean of a three-member ensemble for each model (r1:3i1p1f1). The ensemble mean is compared to an observational dataset at a monthly time resolution. For more information on the observational datasets used, see the <a href="input.html" class="nav-link">input data</a> tab.</p>
      <div class="chart-container">
        <div style="overflow-x:auto; width: 100%;">
          <table id="score-table" class="table" border="0" cellspacing="0" cellpadding="3">
            <thead></thead>
            <tbody></tbody>
          </table>
        </div>
      </div>

      <div class="chart-container">
        <h3 class="chart-head" id="timeseries-title" style="width:100%; margin-top: 2em;">Time Series Analysis</h3>
        <p>The selected metric is calculated at each monthly time step for the regional bounds. Annual data is averaged from the monthly scores.</p>
        <div id="time-series-plot" style="width:100%; height:500px;"></div>
      </div>
    </div>
  </main>
  </main>

  <footer><p>&copy; 2025 CAL.</p></footer>

  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <script>
    let allRows = [];
    let headers = [];
    let tsMonthly = [], tsAnnual = [];
    let benchmarkData = [];
    let crpsData = [];

    const headerDisplayNames = {
      "model": "Model Name",
      "Historical (2005-2014)": "Historical (2005-2014)",
      "SSP2-4.5": "SSP2-4.5",
      "Change (hist 2005)": "Change",
      "Percent Change (hist 2005)": "Percent Change",
    };

    function isCRPSMetric(metric) {
      return metric && metric.includes('crps');
    }

    function getCurrentData() {
      const metVal = document.getElementById('filter-metric').value;
      return isCRPSMetric(metVal) ? crpsData : benchmarkData;
    }

    function renderTable(data) {
      const table = document.getElementById('score-table');
      const thead = table.querySelector('thead');
      const tbody = table.querySelector('tbody');
      thead.innerHTML = '';
      tbody.innerHTML = '';

      // Remove the "variable", "metric", and "region" columns
      const visibleHeaders = headers.filter(h => !['variable', 'metric', 'region'].includes(h));

      const headerRow = document.createElement('tr');
      visibleHeaders.forEach(h => {
        const th = document.createElement('th');
        th.textContent = headerDisplayNames[h] || h;
        headerRow.appendChild(th);
      });
      thead.appendChild(headerRow);

      data.forEach(row => {
        const tr = document.createElement('tr');
        visibleHeaders.forEach(h => {
          const td = document.createElement('td');
          const val = row[h];
          const num = Number(val);
          const isPrecipitation = row['variable'] === 'pr';
          if (!isNaN(num) && isFinite(num)) {
            const isPercentChangeCol = h === "Percent Change (hist 2005)";
            if (isPrecipitation && !isPercentChangeCol) {
              td.textContent = num.toExponential(2); // scientific notation
            } else {
              td.textContent = num.toFixed(3); // normal format
            }
          } else {
            td.textContent = val;
          }
          tr.appendChild(td);
        });
        tbody.appendChild(tr);
      });

      const sortDropdown = document.getElementById('sort-column');
      if (sortDropdown && sortDropdown.options.length <= 1) {
        visibleHeaders.forEach(h => {
          if (h === "model") return;

          const opt = document.createElement('option');
          opt.value = h;
          opt.textContent = headerDisplayNames[h] || h;
          sortDropdown.appendChild(opt);
        });
      }
    }

    function applyFilters() {
      const varVal = document.getElementById('filter-variable').value;
      const metVal = document.getElementById('filter-metric').value;
      const regVal = document.getElementById('filter-region').value;

      const currentData = getCurrentData();
      const filtered = currentData.filter(row =>
        (!varVal || row['variable'] === varVal) &&
        (!metVal || row['metric'] === metVal) &&
        (!regVal || row['region'] === regVal)
      );

      const sortKey = document.getElementById('sort-column').value;

      if (sortKey) {
        filtered.sort((a, b) => {
          const va = parseFloat(a[sortKey]);
          const vb = parseFloat(b[sortKey]);
          if (isNaN(va) || isNaN(vb)) return 0;
          return (va - vb)*-1; // descending
        });
      }

      renderTable(filtered);
    }

    // Load both benchmark and CRPS data
    Promise.all([
      fetch('data/benchmark_results.csv').then(res => res.text()),
      fetch('data/crps_benchmark_results.csv').then(res => res.text())
    ])
    .then(([benchmarkCSV, crpsCSV]) => {
      const benchmarkParsed = Papa.parse(benchmarkCSV, { header: true });
      const crpsParsed = Papa.parse(crpsCSV, { header: true });
      
      benchmarkData = benchmarkParsed.data.filter(row => row.model);
      
      // Remove duplicates from CRPS data based on model, variable, metric, and region
      const crpsDataMap = new Map();
      crpsParsed.data.filter(row => row.model).forEach(row => {
        const key = `${row.model}-${row.variable}-${row.metric}-${row.region}`;
        if (!crpsDataMap.has(key)) {
          crpsDataMap.set(key, row);
        }
      });
      crpsData = Array.from(crpsDataMap.values());
      
      // Set headers from benchmark data initially
      headers = benchmarkParsed.meta.fields.slice(1); // skip unnamed index
      allRows = benchmarkData; // default to benchmark data

      applyFilters(); // auto-filter on load with default dropdown values

      document.getElementById('filter-variable').addEventListener('change', applyFilters);
      document.getElementById('filter-metric').addEventListener('change', applyFilters);
      document.getElementById('filter-region').addEventListener('change', applyFilters);
      document.getElementById('sort-column').addEventListener('change', applyFilters);
    })
    .catch(err => {
      console.error("CSV loading error:", err);
      document.getElementById('score-table').outerHTML = "<p>Error loading benchmark results.</p>";
    });

    // Load time series data
    Promise.all([
      fetch('data/benchmark_results_time_series.csv').then(res => res.text()),
      fetch('data/benchmark_results_time_series_annual.csv').then(res => res.text()),
      fetch('data/crps_benchmark_timeseries.csv').then(res => res.text()),
      fetch('data/crps_benchmark_timeseries_annual.csv').then(res => res.text())
    ])
    .then(([tsMonthlyCSV, tsAnnualCSV, crpsTSMonthlyCSV, crpsTSAnnualCSV]) => {
      tsMonthly = Papa.parse(tsMonthlyCSV, { header: true, dynamicTyping: true }).data;
      tsAnnual = Papa.parse(tsAnnualCSV, { header: true, dynamicTyping: true }).data;
      
      // Parse CRPS time series data (monthly) and convert to match regular format
      const crpsTSMonthlyRaw = Papa.parse(crpsTSMonthlyCSV, { header: true, dynamicTyping: true }).data;
      
      // Convert CRPS monthly data to match timeseries format
      const crpsTSMonthly = crpsTSMonthlyRaw.map(row => ({
        model: row.model_name,
        variable: row.variable_name,
        metric: row.metric,
        time: row.time,
        global: row.global,
        northern_hemisphere: row.northern_hemisphere,
        southern_hemisphere: row.southern_hemisphere,
        tropics: row.tropics
      }));
      
      // Parse CRPS annual time series data and convert to timeseries format
      const crpsTSAnnualRaw = Papa.parse(crpsTSAnnualCSV, { header: true, dynamicTyping: true }).data;
      
      // Convert CRPS annual data to match timeseries format
      const crpsTSAnnual = crpsTSAnnualRaw.map(row => ({
        model: row.model_name,
        variable: row.variable_name,
        metric: row.metric,
        year: new Date(row.time).getFullYear(),
        global: row.global,
        northern_hemisphere: row.northern_hemisphere,
        southern_hemisphere: row.southern_hemisphere,
        tropics: row.tropics
      }));
      
      // Remove duplicates from CRPS time series data
      const crpsTSMonthlyMap = new Map();
      crpsTSMonthly.forEach(row => {
        const key = `${row.model}-${row.variable}-${row.time}-${row.metric}`;
        if (!crpsTSMonthlyMap.has(key)) {
          crpsTSMonthlyMap.set(key, row);
        }
      });
      const deduplicatedCRPSTSMonthly = Array.from(crpsTSMonthlyMap.values());
      
      // Remove duplicates from CRPS annual time series data
      const crpsTSAnnualMap = new Map();
      crpsTSAnnual.forEach(row => {
        const key = `${row.model}-${row.variable}-${row.year}-${row.metric}`;
        if (!crpsTSAnnualMap.has(key)) {
          crpsTSAnnualMap.set(key, row);
        }
      });
      const deduplicatedCRPSTSAnnual = Array.from(crpsTSAnnualMap.values());
      
      // Combine regular and CRPS time series data for monthly
      tsMonthly = [...tsMonthly, ...deduplicatedCRPSTSMonthly];
      
      // Combine regular and CRPS time series data for annual
      tsAnnual = [...tsAnnual, ...deduplicatedCRPSTSAnnual];
      
      setupTimeSeries();
    })
    .catch(err => {
      console.error("Time series CSV loading error:", err);
    });

    function setupTimeSeries() {
      const plotDiv = document.getElementById('time-series-plot');

      function updatePlot() {
        const varVal = document.getElementById('filter-variable').value;
        const regVal = document.getElementById('filter-region').value;
        const metVal = document.getElementById('filter-metric').value;
        const resolution = document.querySelector('input[name="ts-resolution"]:checked').value;

        const metValChart = metVal === "zonal_mean_rmse"
          ? "RMSE"
          : metVal === "zonal_mean_mae"
            ? "MAE"
            : metVal === "zonal_mean_crps"
              ? "CRPS"
              : metVal === "zonal_mean_crps_bias_adjusted"
                ? "CRPS (bias adjusted)"
                : metVal === "zonal_mean_crps_anomaly"
                  ? "CRPS (anomaly)"
                  : NaN;

        // Check if CRPS metric is selected
        const isCRPS = isCRPSMetric(metVal);

        const tsData = resolution === "monthly" ? tsMonthly : tsAnnual;
        const timeKey = resolution === "monthly" ? "time" : "year";
        
        // After conversion, all data uses the same column names
        const modelKey = "model";
        const variableKey = "variable";
        
        const filtered = tsData.filter(d => 
          d[variableKey] === varVal && d.metric === metValChart
        );

        const traces = {};
        filtered.forEach(d => {
          const m = d[modelKey];
          const yVal = parseFloat(d[regVal]);
          if (!isFinite(yVal)) return;

          if (!traces[m]) traces[m] = { x: [], y: [], name: m };
          traces[m].x.push(d[timeKey]);
          traces[m].y.push(yVal);
        });

        const title_var_map = { 'tas': 'surface air temperature (°C)', 'pr': 'precipitation (kg/m2s)', 'clt': 'cloud area fraction (%)', 'tos': 'sea surface temperature (°C)', 'od550aer': 'aerosol optical depth at 550nm' };
        const title_region_map = { 'global': 'global', 'northern_hemisphere': 'northern hemisphere', 'southern_hemisphere': 'southern hemisphere', 'tropics': 'tropical',};
      
        const region = title_region_map[document.getElementById('filter-region').value];
        const variable_name = title_var_map[varVal];

        document.getElementById('timeseries-title').textContent = `${metValChart} of ${resolution} ${region} ${variable_name}`;

        const data = Object.values(traces);
        const layout = {
          // title: `${metValChart} over ${resolution} time for ${varVal} (${regVal.replace('_', ' ')})`,
          // xaxis: { title: resolution === "monthly" ? "Month" : "Year" },
          // yaxis: { title: metValChart },
          legend: { orientation: 'h', x: 0, y: -0.1 }
        };

        Plotly.newPlot(plotDiv, data, layout, { responsive: true });
      }

      // Add listeners
      ['filter-variable','filter-region','filter-metric'].forEach(id => {
        document.getElementById(id).addEventListener('change', updatePlot);
      });
      document.querySelectorAll('input[name="ts-resolution"]').forEach(input => {
        input.addEventListener('change', updatePlot);
      });

      updatePlot(); // initial render
    }
  </script>
</body>
</html>